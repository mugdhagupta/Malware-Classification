import numpy as np
import matplotlib.pyplot as plt
from matplotlib import style
style.use("ggplot")
from sklearn import svm
import os
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import confusion_matrix
import itertools
seed = 7
np.random.seed(seed)

network = [ "GET", "POST", "HTTP Response Packets",  "Server Error", "Client Error", "Redirection", "ip", "dns",  "mdns", "data",  "ssl", "icmp", "igmp", "private ip", "dead host"]
bins = ["netapi", "certificate", "__notification__", "network", "services", "exception", "crypto", "ole", "resource", "ui", "synchronisation", "misc", "process", "file", "system", "registry"]
process = ['dropped_files']

def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap=plt.cm.Blues):
    """
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    """
    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')

    print(cm)

    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    fmt = '.2f' if normalize else 'd'
    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, format(cm[i, j], fmt),
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")

    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')


csvfile_train = <path_to_training_data_csv>
csvfile_test = <path_to_testing_data_csv>

traindata = pd.read_csv(csvfile_train)
testdata = pd.read_csv(csvfile_test)

traindata = traindata[traindata['family'] != "benign"]
testdata = testdata[testdata['family'] != "benign"]

traindata = traindata.sample(frac=1).reset_index(drop=True)

print traindata.shape
print testdata.shape

unique_family_list = ['worms', 'virus', 'trojandropper', 'trojandownloader', 'trojan', 'backdoor',  'pws', 'virtool']
lab_encoder = LabelEncoder().fit(unique_family_list)

def pre_process_data(data):
	list_family = []
	len_data = len(data)
	i=0
	
	for row in data.iterrows():
		i+=1
		if i % 500 == 0:
		    print("%s | %s rows" % (i, len_data))
		type_labelized = lab_encoder.transform([row[1].family])[0]
        	list_family.append(type_labelized)
	
	data = data.drop(['family', 'sha256', 'Attempts to modify Explorer settings to prevent file extensions from being displayed', 'llmnr', 'domain', 'tcp', 'Expresses interest in specific running processes', 'udp', 'Attempts to identify installed AV products by registry key', 'SEARCH', 'modify_security_center_warnings', 'Creates a slightly modified copy of itself', 'nbns', 'Attempts to modify Explorer settings to prevent hidden files from being displayed', 'ip entropy', 'Success', 'ratio public private', 'Total HTTP Packets', 'Queries the disk size which could be used to detect virtual machine with small fixed size or dynamic allocation', 'NOTIFY', 'Disables Windows Security features', 'ssdp', 'Repeatedly searches for a not-found process, you may want to run a web browser during analysis', 'tcp entropy', 'HTTP Request Packets', 'process_count', 'Executes one or more WMI queries which can be used to identify virtual machines', 'http entropy'], axis=1)
	
	#scaling_list = network + bins + process
	#min_max=MinMaxScaler()
	#datanew = min_max.fit_transform(data[scaling_list])

	feat_names = list(data)	
	list_X = data.values
	list_family = np.array(list_family)
	return list_X, list_family, feat_names


X_train, y_train, feat_names = pre_process_data(traindata)
X_test, y_test, feat_names = pre_process_data(testdata)

print feat_names
print X_train.shape
print y_train.shape
print X_test.shape
print y_test.shape

knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(X_train, y_train)
predicted = knn.predict(X_test)


cnf_matrix = confusion_matrix(y_test, predicted)
np.set_printoptions(precision=2)

# Plot non-normalized confusion matrix
plt.figure()
plot_confusion_matrix(cnf_matrix, classes=lab_encoder.inverse_transform(range(8)),
                      title='Confusion matrix, without normalization')

plt.show()


'''neighbors = np.arange(1, 9)
train_accuracy = np.empty(len(neighbors))
test_accuracy = np.empty(len(neighbors))


for i, k in enumerate(neighbors):
    knn = KNeighborsClassifier(n_neighbors=k)
    knn.fit(X_train, y_train)
    train_accuracy[i] = knn.score(X_train, y_train)
    test_accuracy[i] = knn.score(X_test, y_test)


print test_accuracy

plt.title('k-NN: Varying Number of Neighbors')
plt.plot(neighbors, test_accuracy, label = 'Testing Accuracy')
plt.plot(neighbors, train_accuracy, label = 'Training Accuracy')
plt.legend()
plt.xlabel('Number of Neighbors')
plt.ylabel('Accuracy')
plt.show()
'''

